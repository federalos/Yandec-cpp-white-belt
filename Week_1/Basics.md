# Basics

C++ - компилируемый язык программирования, то есть код сначала нужно собрать в исполняемый файл, и только потом запускать исполняемый файл, для получения некоторого результата работы программы. 

## Типа переменных 
С++ - язык со статичной типизацией данных, то есть строгая задача типа переменных( #переменная ) при объявлении. Какие есть типы данных:
- `int  x = 5 ;`
- `double pi = 3.14;`
- `bool logical_value = false;`
- `char symbol = 'Z';`
- Для работы со строкой (набор char), требуется подключение одноимённой дополнительной библиотеки:
	`# include <string>`
	`string hw = "Hello world";`
 
- Есть и другие типы данных, например есть #vector  `<vector>`, который подключается тоже по  отдельной одноимённой библиотеке:
`vector<int> nums = [1, 3, 5, 7];`

У vector есть наборы полезных методов:
	`nums.size(); - получение длины вектора`

Более сложные типы данных: словарь #map  (`<map>`), подключается по отдельной одноимённой библиотеке:
```C++
	map<string, int> name_to_value
	name_to_value ["one"] = 1;
	name_to_value ["two"] = 2;
```
Доступ к по ключу:
	`name_to_value["two"]`

Но это встроенные типы данных, а можно организовать свои типы данных. Для этого можно использовать #структуру: 
	*before main()*
```C++
		struct Person{
			string name;
			string surname;
			int age
		}
```
	*after main*
			`vector<Person> staff;` Объявление вектора состоящего из новых типов данных `Person` и будет хранить в переменной `staff`
		`staff.push_back({"Ivan", "Ivanov", 25});` Добавление в вектор
		`staff.push_back({"Petr", "Petrov", 32});`
	Доступ к данным в этом векторе:
		`staff[0].name;` Из нулевого элемента вектора (первый в списке) взять поле `name`



# Операция #сравнение
- `==` - равно?
- `!=` - не равно?

# #Контейнеры

```C++
#include <iostream>
#include <string>
using namespace std;
int main(){
	string = s "abcdefg";
	for (char c : s){ // перебираются элементы строки #string по элементам символов *char*
	cout << c << ",";
	}
	return 0;
}
```
output:
**a,b,c,d,e,f,g,**

Также можно перебирать вектора. меняется объявление итератора. вместо char будет стоять тот типа данных, которыми заполнен вектор

Но можно дать на откуп компилятору и при объявлении цикла, задать auto;
`for (auto itter : some_vector){`
Это нужно, чтобы избежать дублирование исправлений. Если у нас поменяется хранящийся тип данных в векторах, то тогда не придётся по всем циклам в коде прыгать и исправлять на нужный

```C++
#include <algorithm> - библиотека позволяющая некоторые вещи в одну строчку. например:
#include <iostream>
#include <vector>
using namespace std;
int main(){
	vector<int> = nums = {1, 5, 2, 3, 5};
	int quantity = count(begin(nums), end(nums), 5); // Подсчитать количество пятёрок в векторе nums
	cout << "there are" << quantity << " fives";
	return 0;
	}
```
 Упрощается сортировка:
```C++
	vector<int> = nums = {1, 5, 2, 3, 5};
	 sort(begin(nums), end(nums)); //в порядке возрастания
```


cin - ввод - Consle INput
cout - вывод - Console OUTput

Для вектора вывод в консоль не определён

комментарии:
	однострочный: `//` и далее текст
	Многострочный: `/* insert text here */`

# Debug
Для компиляции в терминале `*.cpp` кода нужно прописать в терминале:
какой комплиятор, какой файл компилировать, ключ `-о`, во какой файл сохранить исполняемый пример:
Пусть есть файл с самим кодом: `main.cpp`
Мы хотим сохранить исполняемый файл в: `main.exe`
Тогда исполняется строчка в терминале:
```
g++.exe \.main.cpp -o main.exe
```

Затем уже можно исполнить сам файл командой: `.\main.exe`


# Конспект от авторов курса:
## Условный оператор #if 

Условный оператор if позволяет указать операции, которые должны выполниться при соблюдении некоторого условия, либо не выполниться, если это условие неверно. 

Синтаксис оператора if в простейшем случае имеет вид: 
```C++
	if ( <условие> ) 
		<команда если верно>
```

Пусть пользователь вводит с консоли два числа, которые потом сравниваются между собой. 
```C++
int a, b;
cin >> a >> b;
if (a == b)
	cout << "equal";
```

Если ввести два одинаковых числа, программа выводит «equal», иначе — ничего не выводит. 

Оператор else позволяет указать утверждение, которое будет выполнено в случае, если условие не верно. Оператор else всегда идет в паре с оператором if и имеет следующий синтаксис: 
```C++
if ( <условие> ) 
	<команда если верно> 
else 
	<команда если неверно> 
```

В результате, программу можно дополнить следующим образом. `int a, b;` 
```C++
cin >> a >> b;
if (a == b)
	cout << "equal" << endl;
else
	cout << "not equal" << endl;
``` 

Если ввести два одинаковых числа, программа выводит «equal», иначе — «not equal». Если необходимо выполнить больше одной операции при выполнении условия, нужно использовать фигурные скобки: 
```C++
if ( <условие> )
	{ ... 
	}
```

Например, можно вывести значения чисел: оба значения, если числа различны, и одно, если совпадают. 
```C++
int a, b;
cin >> a >> b;
if (a == b) {
	cout << "equal" << endl;
	cout << a; }
else {
	cout << "not equal" << endl;
	cout << a << " " << b; }
```

Здесь endl (end of line) — оператор, который делает перенос строки. 
При работе с оператором if следует иметь в виду следующую особенность. Пусть дан такой код: 
```C++
int a = -1;
if (a >= 0)
	if (a > 0)
		cout << "positive";
else
	cout << "negative";
```

Из-за отступов могло показаться, что оператор else относится к внешнему if, а на самом деле в такой записи он относится к внутреннему if. В C++, в отличие от Python, отступы не определяют вложенность. В итоге программа ничего не выводила в консоль. 
Если явно расставить скобки, получится: 
```C++
int a = -1;
if (a >= b) { 
	if (a > 0)
		cout << "positive"; } 
else {
	cout << "negative"; }
```

В данном случае, как и ожидается, выведено «negative». Из последнего примера можно сделать вывод, что следует всегда явно расставлять фигурные скобки, даже если выполнить необходимо всего одну команду. 

## Цикл #while 
Цикл while может быть полезен, если необходимо выполнять некоторые условия много раз, пока истинно некоторое условие. 
```C++
while ( <условие> ) 
	<команда> 
```

Пусть пользователь вводит число n. Требуется подсчитать сумму чисел от 1 до n. 
```C++
int n = 5;
int sum = 0; 
int i = 1;
while (i <= n) {
	sum += i;
	i += 1; }
cout << sum;
``` 

Аналогом цикла while является так называемый цикл do-while, который имеет следующий синтаксис: 
```C++
do {
	<команда>
} while ( <условие> );
```

Следующая программа является интерактивной игрой, в которой пользователь пытается угадать загаданное число. 
```C++
int a = 5;
int b;
do {
	cout << "Guess the number: ";
	cin >> b;
} while (a != b);
cout << "You are right!"; 
```

## Цикл #for 
Цикл for используется для перебора набора значений. В качестве набора значений можно использовать некоторые типы контейнеров: 
- **vector** 
```C++
	vector a = {1, 4, 6, 8, 10};
	int sum = 0;
	for (auto i : a) {
		sum += i; }
	cout << sum;
```
- **map** 
```C++
	map b = {{"a", 1}, {"b", 2}, {"c", 3}};
	int sum = 0;
	string concat;
	for (auto i : b) {
		concat += i.first;
		sum += i.second; }
	cout << concat << endl;
	cout << sum;
```
- **string** 
```C++
	string a = "asdfasdfasdf";
	int i = 0;
	for (auto c : a) {
		if (c == 'a') {
			cout << i << endl; }
		++i; }
```
		 

Простой цикл for позволяет создавать цикл с индексом: 
```C++
string a = "asdfasdfasdf";
for (int i = 0; i < a.size(); ++i) {
	if (a[i] == 'a') {
		cout << i << endl; }
}
```
С помощью оператора break можно прервать выполнение цикла: string 
```C++
a = "sdfasdfasdf";
for (int i = 0; i < a.size(); ++i) {
	if (a[i] == 'a') {
		cout << i << endl;
		break; }
}
cout << "Yes";
```

3 
Yes

Дополнение из недели 3:
пусть есть следующий кусок псевдопрограммки, где хотели бы увеличить каждый элемент вектора на 1:
```C++
vector<int> v = {1,3,2,5,4}
for (auto i : v){
i++;
}
```
В данном случае увеличения не произойдёт, так как при итерации `i` по вектору `v` создаётся копия вектора `v`. Здесь можно прибегнуть к ссылке и тогда увеличение будет происходит, как и ожидалось:
```C++
vector<int> v = {1,3,2,5,4}
for (auto& i : v){
i++;
}
```
Копирования ненужного стоит избегать, но и стоит себя обезопашиваться от лишнего изменения внутренностей цикла через "константные ссылки":
```C++
vector<int> v = {1,3,2,5,4}
for (const auto& i : v){
 cout << i << " ";
}
```
#  Домашние задания ( #HW )
1. [Деление](1_Division/division.md)
2. [Расчёт стоимости товара](2_Discount/Discount.md)
3. [Чётные числа](3_Odd_numbers/odd.md)
4. [Второе вхождение](4_Second_F/Second_F.md)
5. [Наибольший общий делитель](5_Greatest_common_divisor/Greatest_Divisor.md)
6. [Двоичные числа](6_Dec_To_Bin/DecToBin.md)

Здесь решены не все, но те, которые могут быть значимыми. Пропущены были те задания из Coursera, которые были слишком лёгкие для реализации даже для меня.