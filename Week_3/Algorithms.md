# Algorithms

При написании программы следует избегать придумывания велосипеда: некоторые функции уже готовы и входят в состав стандартных библиотек. Так например в:
```C++
#include <algorithm>
```
определены такие функции как `min()`  `max()`. Они работают с любыми контейнерами, для которых определены логические команды `<, >, ==, !=`
Или например функцию `sort()`, которая сортирует выбранный контейнер. пример вызова функции:
```c++
vector<int> v = {1, 3, 2, 5, 4};
sort(begin(v), end(v));
```
`begin(v)` - это итератор начала контейнера откуда будет проведена сортировка
`end(v)` - конец вектора
Подробнее про функцию `sort()` можно почитать по [ссылке](https://cplusplus.com/reference/algorithm/sort/?kw=sort)  

Подсчёт элементов в контейнере можно также осуществить через встроенные алгоритм `count(begin(v), end(v), 2)` - С какого элемента `begin(v)` по какой элемент `end(v)` посчитать сколько раз встретился элемент `2`. 
Для подсчёта количества элементов в контейнере отвечающим некоторым условиям можно оформить через `count_if()` и lambda-функции.
```c++
bool func(int x){
	if (x > 2){
		return true;
	}
	return false;
}
/*
*/
count_if(begin(v), end(v), func)
```

#lambda-функция - это однострочная функция, которая позволяет оформить функцию для одного применения в теле программы. Нужно, чтобы не захламлять "функциями одного применения" свой код. То же что и выше, только через lambda-выражение
```C++
int thr = 2;
count_if(begin(v), end(v), [thr](int x), {
							if (x > thr) {
							return true;} 
							return false;})
```
В таком случае оформлять какую-то внешнюю функцию не нужно. синтаксис у лямбда-выражения следующих:
```C++
[t](int x) {return x>t}
```
`t` - это захватываемый элемент (переменная) из внешней среды по отношению к самой лямбда-функции (правила доступа к переменным внутри лямбда функции такие же как и в случае с обычной функцией). 
`(int x)` - определяется вход этой функции, который будет использовать в дальнейшем в самой функции
`{/**/}` -  тело самой лямбда-функции
Полезные методы:
- `tolower()` -  [Ссылка](https://cplusplus.com/reference/cctype/tolower/)

## Область видимости переменных
Ссылаться на переменную (и использовать) можно только после того, как она была объявлена: 
```C++
cout << x; int x = 5;
``` 
Такой код даже не скомпилируется. Компилятор выдаст ошибку 
```
’x’ was not declared in this scope»
```

Если же поменять строчки местами, программа заработает. 

Другой пример: 
```C++
{ 
	int x = 5; 
	{ 
		cout << x; 
	} 
	cout << x; 
} 
cout << x; 
```
Здесь переменная `x` определена внутри операторных скобок, и в трех местах кода имеет место попытка вывести ее на экран. При этом программа не компилируется: компилятор указывает на ошибку при попытке вывести на экран `x` за пределами первых операторных скобок. Если эту строчку закомментировать, программа успешно скомпилируется: 
```C++
{ 
	int x = 5; 
	{ 
		cout << x; 
	} cout << x; 
} 
//cout << x; 
```
Таким образом, переменные в C++ видны только после своего объявления и до конца блока, в котором были объявлены. Например, следующий код с условным оператором не скомпилируется: 
```C++
if (1 > 0) { 
	int x = 5; 
} 
cout << x; 
```
Это связано с тем, что переменная объявлена внутри тела условного оператора. То же самое имеет место для цикла while: 
```C++
while (1 > 0) { 
	int x = 5; 
} 
cout << x;
``` 
И для цикла for: 
```C++
for (int i = 0; i < 10; ++i) { 
	int x = 5; 
} 
cout << x;
``` 
Может возникнуть вопрос: видна ли переменная `i`, которая была объявлена как счетчик цикла: 
```C++
for (int i = 0; i < 10; ++i) { 
	int x = 5; 
} 
cout << i; 
```
Оказывается, что она также не видна. Еще один пример: 
```C++
string s = "hello"; 
{ 
	string s = "world"; 
	cout << s << endl; 
} 
cout << s << endl; 
```
Здесь переменная s определена как внутри операторных скобок, так и вне их. Программа компилируется и выводит: 
```
world hello 
```
Однако использование одинаковых имен, хоть не вызывает ошибку компиляции, считается плохим стилем, так как усложняет понимание кода и увеличивает вероятность ошибиться. 

### Инициализация переменной 
Пусть функция `PrintInt` объявляет переменную типа `int` и выводит на экран: 
```C++
void PrintInt() { 
	int x; 
	cout << x << endl; 
}
``` 
Пусть также определена функция `PrintDouble`, в которой определяется переменная типа `double` и ей сразу присваивается значение. Переменная также выводится на экран. 
```C++
void PrintDouble() { 
	double pi = 3.14; 
	cout << pi << endl; 
} 
```
Пусть в `main` сначала вызывается функция `PrintInt`, а за ней — `PrintDouble`: 
```C++
PrintInt(); 
PrintDouble(); 
```
Такая программа компилируется без ошибок. Интерес представляет то, какое значение x будет выведено на экран, поскольку значение этой переменной установлено не было. Можно предположить, что по умолчанию значение переменной x будет равной 0. Программа выводит: 
```
0 
3.14
``` 
Теперь рассмотрим другую ситуацию, когда после функции `PrintDouble` еще раз вызывается `PrintInt`: 
```C++
PrintInt(); 
PrintDouble(); 
PrintInt(); 
```
В результате работы программы: 
```
0 
3.14 
1074339512
``` 
Вместо нуля при втором вызове `PrintInt` выводится какое-то большое странное число, а не ноль. Этот пример показывает, что значение неинициализированной переменной не определено. У этого есть рациональное объяснение. Автор C++ руководствовался принципом **«zero overhead principle»**  ("Не платить за то, что не используется"):
```C++
int value; // мне все равно, что будет в переменной value 
int value = 0; // мне необходимо, чтобы в value был ноль 
```

Отсюда следует вывод: переменные нужно инициализировать при их объявлении. Так получится защититься от ситуации, что в переменной неожиданно окажется мусор, а не ожидаемое значение. 

### Инициализация переменной при объявлении: примеры

Следующая функция печатает, является ли переданное в качестве параметра число четным:
```C++
void PrintParity(int x) { 
	string parity; 
	if (x % 2 == 0) { 
		parity = "even"; 
	} else { 
	parity = "odd"; 
	} 
	cout << x << " is " << parity; 
} 
```
В этом случае, казалось бы, не получается инициализировать переменную при ее объявлении. Однако этого можно добиться с помощью **тернарного оператора** ( #тернарный_оператор ): 
```C++
void PrintParity(int x) { 
string parity = (x % 2 == 0) ? "even": "odd"; 
cout << x << " is " << parity; 
} 
```
Следующая функция выводит на экран, является ли число положительным, отрицательным или нулем: 
```C++
void PrintPositivity(int x) { 
	string positivity; 
	if (x > 0) { 
		positivity = "positive"; 
	} else if (x < 0) { 
		positivity = "negative"; 
	} else { 
		positivity = "zero"; 
	} 
	cout << x << " is " << positivity; 
}
``` 
В этом случае также хочется добиться инициализации переменной при ее объявлении. Для этого можно вынести часть кода в отдельную функцию: 
```C++
string GetPositivity(int x){ 
	if (x > 0) { 
		return "positive"; 
	} else if (x < 0) { 
		return "negative"; 
	} else { 
		return "zero"; 
	} 
} 
```
В этом случае переменная `positivity` может быть инициализирована в месте ее объявления: 
```C++
void PrintPositivity(int x){ 
	string positivity = GetPositivity(x); 
	cout << x << " is " << positivity; 
}
```
Но на самом деле можно использовать многослойные тернарные операторы, например для задачи выше функцию `GetPositivity` можно переписать следующим образом:
```C++
string GetPositivity(int x) {
    return x > 0 ? "positive"
                 : (x == 0 ? "zero" : "negative");
}
```

# Введение в ООП
Ядро ООП - это создание своих структур данных. Рассмотрим пример из лекции:
Пусть мы хотим вызывать вывод информации о лекции из курса. И пусть у нас есть только названия лекций. Тогда функция вывода названий лекций из курса будет выглядит следующим образом:
```C++
void PrintLecture (const string& title){
	cout << "Title: " << title << endl;
}
```
Вроде просто. Но что будет, если мы добавим информацию о лекции? Например длительность этой лекции, то к каким проблем этот приведёт? Что нам нужно будет поменять в коде, чтобы он выводил то, что нам нужно? Вот:
```C++
void PrintLecture (const string& title, int duration){
	cout << "Title: " << title << ", duration: " << duration << endl;
}
```

А теперь что будет, если у нас появится несколько лекций в курсе? Мы опять наталкиваемся на неизбежную модификацию как самой функции, её вызова, так и аргументов вызова функции:
```C++
void PrintLecture (const string& title, int duration){
	cout << "Title: " << title << ", duration: " << duration << endl;
}
void PrintCourse (const vector<string>& titles, const vector<int>& durations){
	int i = 0;
	while (i < title.size()){
		PrintLecture(titles[i], durations[i]);
		i++;
	}
}
```
И все эти характеристики хранятся отдельно, независимо друг от друга, хотя идейно, они должны быть связаны между собой.
А теперь появилась необходимость хранить авторов лекций. Тем самым, появляется доп-характеристика, которую нужно обрабатывать в функциях. То есть нужно модифицировать функции `PrintLecture()`
```C++
void PrintLecture (const string& title, int duration, const string& author){
	cout << "Title: " << title << ", duration: " << duration << ", author: " << author <<  endl;
}
```
И функцию `PrintCourse()`:

```C++
void PrintCourse (const vector<string>& titles, const vector<int>& durations, const vector<string>& authors){
	int i = 0;
	while (i < title.size()){
		PrintLecture(titles[i], durations[i], authors[i]);
		i++;
	}
}
```
И всё это приводит к тому, что такой код сложнее поддерживать при добавлении новой характеристики. При добавлении новой характеристики или удалении какой-то характеристики (одного из векторов), нам необходимо это исправлять во всём полотне программы. А это тяжело (особенно, когда речь идёт об одной характеристики из 10 или 100)
И более того, мы определяем какие-то сущности в неявном формате. То есть различные несвязанные кодом характеристики, описывают одну сущность. Что контринтуитивно.
И вот для решения этих проблем нужны собственные типы данных. Это можно сделать через написание структуры ( #struct ):
```C++
struct Lecture { // Состовной тип из 3 полей
	string title;
	int duration;
	string author;
};
```
И тогда функции для вывода переписываются в следующий вид:
```C++
void PrintLecture (const Lecture& lecture){
	cout << "Title: " << lecture.title << 
	", duration: " << lecture.duration << 
	", author: " << lecture.author <<  endl;
}
void PrintCourse (const vector<Lecture>& lectures){
	for (const Lecture& lecture : lectures){
		PrintLecture(lecture);
	}
}
```
Функция `PrintCourse` стала более понятно, с точки зрения читающего код. В добавок, она перестала нуждаться в дальнейших модификациях, при изменении данных. Стала более универсальной.
Заполнять поля или получать доступ к полям можно через точку:
```C++
Lecture lecture1;
lecture1.title = "Name";
lecture1.duration = 360;
lecture1.author = "Anton";
```
Но есть более компактный способ присвоить значение полям:
```
Lecture lecture2 = {"Name", 360, "Anton"};
```
Структуры можно спокойно оформлять вложенными. То есть например есть какая-то структура_1, и внутри этой структуры идёт ссылка на структуру_2. Это называется "вложенные структуры":
```C++
struct LectureTitle{
	string specializations;
	string course;
	string week;
};
struct DetailedLecture{
	LectureTitle title;
	int duration;
};
```
ВАЖНО! порядок объявление структур - важен для компиляции (как переменными). Сначала объявляется, потом уже используется. Если поменять местами структуры `DetailedLecture` `LectureTitle` (сначала эта структура, которая имеет ссылка вторую структуру), то такой код не скомпилируется.
Обращение и присвоение значение полям новой структуры:
```C++
LectureTitle title = {"c++", "White belt", "OOP"};
DetailedLecture lecture_1 = {title, 360};
```
Либо без временной переменной, как выше:
```C++
DetailedLecture lecture_ _2 = {{"c++", "White belt", "OOP"}, 360};
```
Пример обращения к вложенным полям через точки (каждое вложение - новая точка):
```C++
lecture_2.title.specializations
```
Поля структуры можно объявлять по умолчанию. Например, мы хотим до вызывая структуру, чтобы там что-то уже находилось, тогда можно просто при описании структуры присвоить значения нужным полям:
```C++
struct Lecture{
	string title = "C++";
	int duration = 0; 
};
```
И тогда появляется опция в основном теле программы сделать следующее:
```C++
Lecture lecture;
cout << lecture.title << " " << lecture.duration << "\n";
// out: C++ 0
```
И при этом можно всё ещё передавать параметры в структуру и переобъявлять их:
```C++
Lecture lecture2 = {"OOP", 5400};
// это тоже работает
```
Более того, можно сделать вот так:
```C++
Lecture lecture3 = {"OOP"};
// lecture3.duration будет равно 0
```


# Классы ( #class )

Понимать классы можно начать с описания "Приватная секция". Рассмотрим пример: структура, которая получает 2 города на карте и функция, которая как-то высчитывает дистанцию между этими городами:
```C++
struct Route{
	string source;
	string destination;
};
int ComputeDistance(const string& source, const string& destination);
}
```
Функция `ComputeDistance()` может быть тяжёлой и затратной, для частого вызова, поэтому можно было бы рассчитать эту дистанция единожды для 2 полей в структуре и хранить, как третье поле. И тогда структура будет иметь вид:
```C++
struct Route{
	string source;
	string destination;
	int length;
};
```
Но тогда получается, что мы не гарантируем в программе что дистанция между `source` и `destination` является `length`. Всё потому что все поля в структуре сейчас можно изменить извне и создать ситуация: объявить начало и конец маршрута, рассчитать конец маршрута (с помощью функции выше из тела программы), переобозначить начало маршрута и не обновить дистанцию. Такое может быть довольно частой проблемой. И тогда хотим минимизировать подобные ситуации. А это можно добиться приватностью некоторых полей, иными словами: запретить прямой доступ к полям:
```C++
struct Route{
	private:
		string source;
		string destination;
		int length;
};
```
И теперь к всем полям структуры `Route` нет доступа извне (ни прочитать, ни изменить мы их не сможем где-то в `main()` ). Да, сейчас эта структура довольно бесполезна. Но для развития этой структуры нам нужны #методы  с правами "только чтение":
```C++
struct Route{
	public: // Публичная секция
		string GetSource() {return source;}
		string GetDestination() {
			return destination; 
		}
		int GetLength () {return length;}
	private: // Приватная секция
		string source;
		string destination;
		int length;
};
```
В публичной секции мы определили методы, который сильно схожи с функциями, используемые ранее по курсу. Но эти методы привязаны только к конкретным классам и они работают только внутри некоторого объектного маршрута.  То есть методы вызываются в контексте этого объекта
Логика использования в программе структуры с методами схож, с обращением к полям:
```C++
Route route;

route.GetSource() = "Moscow" // Сейчас у нас нет возможности как-то изменять начало маршрута

cout << route.GetLength() // Получим длину машрута через метод структуры

int destination_name_length = route.GetDestination().length();
// здесь отработала цепочка нашей кастомной структуры и методов над string. Мы узнали длину названия финальной точки
```
А теперь магия. По факту, та структура, которая была описана выше - это уже формально не структура, а класс ( #class ). И строго говоря, стоит объявлять её соответствующе:
```C++
class Route{
	public: // Публичная секция
		string GetSource() {return source;}
		string GetDestination() {
			return destination; 
		}
		int GetLength () {return length;}
	private: // Приватная секция
		string source;
		string destination;
		int length;
};
```
Чтобы было больше ясности, `struct` - это набор полей и контролировать консистентность (смысловая связь между полями) не нужно (набор публичных полей с открытым доступом), а `class` - это уже набор полей, с правами доступа и методами, иными словами класс скрывает некоторые данные, предоставляя определённый интерфейс доступа к ним и используется тогда, когда поля связаны друг с другом и эту связь необходимо строго контролировать. 
Но пример выше ещё незакончен. Этот класс пока что довольно статичный, и нам бы хотелось сохраняя контроль на данными, задавать новые значения в полях (и чтобы длина соотносилась уже с обновлёнными городами, даже если они обновились).

```C++
class Route {
	public:
	// ... ранее описаные методы
		string GetSource() {return source;}
		string GetDestination() {return destination;}
		int GetLength () {return length;}
		void SetSource(const string& new_source){
			source = new_source;
			UpdateLength(); // при изменении начала, обновляем значение расстояние
			}
		void SetDestination (const string& new_Destination){
			Destination = new_Destination;
			UpdateLength(); // при изменении конца, обновляем значение расстояние
			}

	private:
		void UpdateLength(){ // этот метод должен быть закрытым и мы не должны извне его изменять. Он только обновляет поле, в соответствии с инфой из других полей
			length = ComputeDistance(source, destination);
			}
		string source;
		string destination;
		int length;
}
```
И тогда использование этого класса в теле программы будет иметь вид:
```C++
Route route;
route.SetSource("Moscow");
route.SetDestination("Dubna");
cout << "Route from " << 
	route.GetSource() << " to "<< 
	route.GetDestination() << " is "<<
	route.GetLength() << " meters long"; 	
```
##  #Конструктор

Хорошо, у нас есть класс, в классе есть set-еры, которые задают значения значение полей структуры. Но рассмотрим, как происходит объявление полей с внешней стороны (со стороны внешнего наблюдателя):
```C++
Route route;
route.SetSource("Zvenigorod");
route.SetDestination("Istra");
```
Три строчки на типовое объявление маршрута. Первое решение, которое приходит на ум - это объявить какую-то внешнюю функцию:
```C++
Route BuildRoute(const string& source, const string& destination){
Route route;
route.SetSorce(source);
route.SetDestination(destination);
}
```
И вызывать в основном теле программы уже функцию:
```C++
Route route = BuildRoute("Zvenigorod", "Istra");
```
Но есть проблема: не стандартизованное название лекции, которое при этом сильно зависит от класса и его приверженности (например, вместо build будет make, create и так далее). При проекте над которым работает команда, подобное несогласованность, может фрустрировать. Та и в принципе, решение какое-то костыльное, можно лучше. И вот тут на сцену выходят конструкторы. И ими мы уже пользовались. Вспомним, например, вот такие строчки при объявлении новых переменных:
```C++
vector<string> names(5);
string spaces(10, ' ');
```
Конструктор позволяет красиво оформить код + эффективно. То есть хочется нам тоже сделать что-то такое:
```
Route route("Zvenigorod", "Istra"); 
```
Итак, #конструктор - это специальный метод класса, у которого нет возвращаемого значения и название этого метода совпадает с названием класса. Вот так будет выглядеть в нашем случае конструктор в классе:
```C++
class Route{
	public:
		Route(const string& new_source, const string& new_destination){
			SetSorce(new_source);
			SetDestination(new_destination);}
};
```
И уже после этого в основном теле программы можно будет вызывать:
```C++
Route route("Zvenigorod", "Istra"); 
```
Но тут опять проблема есть в неэффективности. Внутри наших set-ов  есть обновление дистанции по методу `UpdateLength()`. То есть мы дважды пересчитываем дистанцию, хотя ожидается, что мы сначала введём 2 точки, а только после этого нужна дистанция. Тогда перепишем конструктор без set-ов по новой:
```C++
class Route{
	public:
		Route(const string& new_source, const string& new_destination){
			source = new_source;
			destination = new_destination;
			UpdateLength();
			}
};
```
То что мы описали выше - это параметризованный конструктор. И теперь мы обязаны обращаться к объекту по 2 параметрам: начало пути и конец пути. Иными словами, мы не сможем сделать следующее, при наличии текущего конструктора:
```
Route route; // ошибка компиляции
```
И тогда можно оформить конструктор по умолчанию, выглядеть это будет, как отдельный метод с таким же названием в публичном поле но без аргументов и без вывода (пустой методы):
```C++
class Route{
	public:
		Route() {} // конструктор по умолчанию
		Route(const string& new_source, const string& new_destination){
			source = new_source;
			destination = new_destination;
			UpdateLength();
			}
};
```
Можно задать внутри конструктора по умолчанию какие-то стартовые значение, например:
```C++
class Route{
	public:
		Route() {
			source = "Moscow";
			destination = "Saint-Petersburg";
			UpdateLength();
		} // конструктор по умолчанию
		Route(const string& new_source, const string& new_destination){
			source = new_source;
			destination = new_destination;
			UpdateLength();
			}
};
```
## #Деструкторы
Это метод, который вызывается при уничтожении объекта, противоположность к конструктору. Первостепенное назначение: это откат действий, которые сделал конструктор. Это, например, закрытие открытого файла, или освобождение вручную выделенного участка памяти. Ещё одной фиче деструктора - вывод отладочной информации. Возьмём пример из лекции:
```c++
#include <string>;
#include <iostream>

using namespace std;

//заглушка-функция
int ComputeDistance(const string& source, const string& destination){
	return source.length() - destination.length();
}

class Route{
	public:
		Route(){
			source = "Moscow";
			destination = "Saint Petersburg";
			UpdateLength();
		}
		Route (const string& new_source, const string& new_destination){
			source = new_source;
			destination = new_destination;
			UpdateLength();
		}
		string GetSource() const {return source;}
		string GetDestination() const {return destination;}
		int GetLength() const {return length;}
		void SetSource(const string& new_source) {
			source = new_source;
			UpdateLength();
		}
		void SetDestination(const string& new_destination){
			destination = new_destination;
			UpdateLength();
		}
	private:
		void UpdateLength(){
			length = ComputeDistance(source, destination);
		}
		string source;
		string destination;
		int length;
	}

int main(){
	return 0;
}
```
Мы хотим для данной программы узнать, для каких городов вызывалась метод `UpdateLength` . Для этого можно создать "лог вызова функции `ComputeDistance`". Сделаем поле `vector<string> compute_distance_log` и обновим метод `UpdateLength` следующим образом:
```c++
	private:
		void UpdateLength(){
			length = ComputeDistance(source, destination);
			compute_distance_log.push_back(source + " " + destination);
			
		}
		string source;
		string destination;
		int length;
		vector<string> compute_distance_log;
```
И вывести после того, как объект уничтожится, то есть через деструктор:
```C++
class Route{
	public:
	/*smt*/
	
	// объявление деструктора
	// метод ничего не возвращает
	// имеет такое же название, что и сам класс
	// начинается со специального символа ~
	~Route () {
		for (const string& entry : compute_distance_log){
			cout << entry << endl;
			}
	}
	
	/*smt*/
```

По завершению `main()`, на строчке `return 0;` автоматически запустится деструктор объекта. В принципе тут работает правильно с видимостью переменной, то есть если переменная должна очистить место в памяти, то запуститься деструктор. Это можно происходить внутри циклов, внутри фигурных скобок `{/**/}`, внутри функций и подобные случаи.
Компилятор уничтожает объекты в обратном порядке от их вызова в программе: *кто создался последним, уничтожится первым. Кто создался первым, уничтожится последним.* 
# Домашние задания ( #HW )
1. [Сортировка целых чисел по модулю](/Week_3/1_Abs_sorting/Abs_Sorting.md)
2. [Сортировка без учёта регистра](/Week_3/2_Sorting_string/Sorting_string.md)
3. [Отсортированные строки](/Week_3/3_Sorted_string/Sorted_string.md)
4. [Имена и фамилии — 1](/Week_3/4_Names_Surnames_1/Names_Surnames_1.md)
5. [Имена и фамилии — 2](/Week_3/5_Names_Surnames_2/Names_Surnames_2.md)
6. [Строка](/Week_3/6_String/String.md)
7. [Имена и фамилии — 3](/Week_3/7_Names_Surnames_3/Names_Surnames_3.md)
8. [Способы инициализации](/Week_3/8_Init/Init.md)