Разделение кода на функции помогает в понимании: есть не целого слона, а по частям. Важно только именовать функции в соответствии с тем, что эта функция делает. 

При правильной проектировки функции, можно будет в дальнейшем проще повторить этот кусок кода простым вызовом функции. Например, расчёт некоторой метрики на различных участках обработки данных

Единственный способ рекурсивных алгоритмов (!)

синтаксис довольно простой:

```C++
int func(int x, int y){
	*do smth*
	return result;
}
int main (){
	*do smth*
	func(a,b);
	return 0;
}
```

Сперва объявляется тип возвращаемого значения функции (то что функция будет выплёвывать по return). Это делается при объявлении функции.
Затем имя функции
в круглых скобках - перечисление параметров, подаваемые на вход функции с обязательным указанием их типов
`return` - завершает работу функции, даже если эта команда была в середине функции. Аналогично работе циклов и команды `break`

Если нужно, чтобы функция просто отработала и ничего не возвращала вовне (например какой-то настроенный вывод данных на экран) используется тип 
```C++
void func(_,_)
```

ВАЖНО: параметры функции передаются по значению, то есть внутри функции работ осуществляется не с первоначальными значениями, а их копиями. Иными словами: то что было в функции, остаётся в функции

Что если нужно всё-таки внести изменения исходные входных аргументов функции, не копии переменных, подаваемых в функцию. Тогда можно передавать не копию, а ссылку #ссылка :
`void Swap(int& x, int&y){...}`
здесь `int&` - это ссылка на переменную Х в `main()`

Ещё с помощью ссылок можно избавиться от дублирования объявления типов. Например
```C++
vector<int> Sort (vector<int> v){
	sort(begin(v),end(v));
	return v;
}
```
В примере кода выше тип выходных данных функции дублирует тот тип данных, который подаётся на вход. Но можно переделать с использованием ссылок:
```C++
void Sort (vector<int>& v){
	sort(begin(v),end(v));
}
```

Важный момент с этими ссылками и "аргументами по значению" это время работы. При передачи аргумента без ссылок в функцию делается копия, это мы уже выяснили. А теперь представим, что нужно сделать копию огромного массива. Это приведёт к 2 проблемам: больше памяти на работу одной программы + больше времени исполнения (из-за глубокого полного копирования). Здесь тоже может помочь передачи значения по ссылке, так как в таком случае никакого копирования не происходит и на выходе 
Но это не панацея. Зачастую, при передаче ссылки в функцию ожидается (и другими программистами тоже), что эта функция будет что-то делать с аргументами, передаваемыми в функцию: как-то их изменять. Но если функцию их не изменяет? Например, если это функцию занимается отображение инфы об аргументе. Тогда подобный синтаксис вызовет вопросы у других программистов из-за не очевидности. Более того, есть дополнительная проблема, "результат вызова одной функции не может быть передан по ссылке в другую функцию". 

Для решения подобных проблем можно использовать #константная_ссылка:
```C++
void Func_Name(const vector<Person>& p){...}
```
Константная ссылка даёт запрет на изменение исходного значения, которое оказалось в функции.

В целом #const - это такой модификатор, который запрещает любые изменения переменной. То есть его можно использовать и при объявлении обычных переменных:
`const int num = 1;`
И тогда в дальнейшем у нас будет ошибка при компиляции, если мы захотим работать с `num` в режиме не read-only. То есть если мы захотим num++, тогда компилятор не даст нам этого сделать. Это полезная фича для фиксирования некоторых постоянных переменных в программе от случайного их изменения.

Для примера рассмотрим вырезку из конспекта авторов курса:

Раньше было показано, как в С++ можно создавать свои типы данных. А именно была определена структура Person: 
```C++
struct Person { 
	string name; 
	string surname; 
	int age; }; 
```

Допустим, что была проведена перепись Москвы и вектор из Person, который содержит в себе данные про всех жителей Москвы, можно получить с помощью функции GetMoscowPopulation: 
```C++
vector GetMoscowPopulation(); 
```


Здесь специально не приводится тело этой функции, которое может быть устроено очень сложно, отправлять запросы к базам данных и так далее. Вызвать эту функцию можно так:
```C++
vector moscow_population = GetMoscowPopulation(); 
```

Требуется написать функцию, которая выводит на экран количество людей, живущих в Москве. Эта функция ничего не возвращает, принимает в качестве параметра вектор людей и выводит красивое сообщение: 
```C++
void PrintPopulationSize(vector p) { 
	cout << "There are " << p.size() << " people in Moscow" << endl; 
	} 
```

Воспользуемся этой функцией:
```C++
vector moscow_population = GetMoscowPopulation(); 
PrintPopulationSize(moscow_population); 
```

Программа вывела, что в Москве 12500000 людей: *«There are 12500000 people in Moscow»*. 
Замерим время выполнение функции GetMoscowPopulation и функции PrintPopulationSize. Подключим специальную библиотеку для работы с промежутками времени, которая называется #chrono: 
```C++
#include <chrono>
#include <iostream>
#include <vector>
#include <string>

using namespace std;
using namespace std::chrono;
```

После этого до и после места вызова каждой из интересующих функций получим текущее значение времени, а затем выведем на экран разницу: 
```C++
auto start = steady_clock::now(); 
vector moscow_population = GetMoscowPopulation(); 
auto finish = steady_clock::now(); 
cout << "GetMoscowPopulation " 
	<< duration_cast(finish - start).count() 
	<< " ms" << endl; 
start = steady_clock::now(); 
PrintPopulationSize(moscow_population); 
finish = steady_clock::now(); 
cout << "PrintPopulationSize " 
	<< duration_cast(finish - start).count() 
	<< " ms" << endl;
```


 В результате получаем: 
```
 GetMoscowPopulation 609 ms 
 There are 12500000 people in Moscow 
 PrintPopulationSize 1034 ms
```
 
Получается, что функция, которая возвращает вектор из 12 миллионов строк, работает быстрее функции, которая всего-то печатает размер этого вектора. Функция PrintPopulationSize ничего больше не делает, но работает дольше. Но мы уже говорили, что при передаче параметров в функции происходит полное глубокое копирование передаваемых переменных, в данном случае — вектора из 12 500 000 элементов. Фактически, чтобы вывести на экран размер вектора, мы тратим целую секунду на его полное копирование. С этим нужно как-то бороться. 
Избежать копирования можно с помощью передачи параметров по ссылке: 
```C++
void PrintPopulationSize(vector& p) { 
	cout << "There are " << p.size() << 
		" people in Moscow" << endl;
} 
```

Output
```
GetMoscowPopulation 609 ms 
There are 12500000 people in Moscow 
PrintPopulationSize 0 ms
```

Теперь все работает хорошо, но у данного способа есть несколько недостатков: 
- Передача параметра по ссылке — способ изменить переданный объект. Но в данном случае функция не меняет объект, а просто печатает его размер. Объявление этой функции
```C++
void PrintPopulationSize(vector& p)
``` 
  может сбивать с толку. Может создаться впечатление, что функция как-то меняет свой аргумент. 
- В случае, если промежуточная переменная не создается: 
```C++
PrintPopulationSize(GetMoscowPopulation());
```
  программа даже не скомпилируется. Дело в том, что в C++ результат вызова функции не может быть передан по ссылке в другую функцию (почему это так будет сказано позже в курсе). 
  
Получается, что при передаче по значению, мы вынуждены мириться с глубоким копированием всего вектора при каждом вызове функции печати размера, а при передаче по ссылке — мириться с вышеназванными двумя проблемами. Существует ли идеальное решение без всех этих недостатков? 
  Выход заключается в использовании передачи параметров по так называемой константной ссылке. Это делается с помощью ключевого слова const, которое добавляется слева от типа параметра. Символ & остается на месте и указывает, что происходит передача по ссылке. Определение функции принимает вид: 
```C++
  void PrintPopulationSize(const vector& p) { 
	  cout << "There are " << p.size() << 
		  " people in Moscow" << endl; 
	  } 
```
В результате PrintPopulationSize выполняется за 0 мс, а также работает передача результата вызова функции в качестве параметра другой функции по константной ссылке: 
```C++
PrintPopulationSize(GetMoscowPopulation()); 
```

Также мы не вводим в заблуждение пользователей нашей функции и явно указываем, что параметр не будет изменен, так как он передается по константной ссылке. Такой подход также защищает от случайного изменения фактических параметров функций. Допустим, по ошибке в функцию печати количества людей в Москве попал код, добавляющий туда одного жителя Санкт-Петербурга. ```
```C++
void PrintPopulationSize(const vector& p) {
	cout << "There are " << p.size() << 
		" people in Moscow" << endl; 
	p.push_back({"Vladimir", "Petrov", 40}); 
} 
```

В случае передачи по ссылке такая ошибка могла бы остаться незамеченной, но при передаче по константной ссылке такая программа даже не скомпилируется: 
```C++
main.cpp: In function 'void PrintPopulationSize (const std :: vector < Person >&) ': main.cpp :20:41: error: passing 'const std :: vector ' as 'this ' argument discards qualifiers [−fpermissive ] p. push_back ({" Vladimir ", "Petrov", 40});
```

 Компилятор в таком случае выдает ошибку, так как нельзя изменять принятые по константной ссылке фактические параметры.


# #Контейнеры 
## #vector

Векторы - это набор элементов указанного типа, иными словами последовательность некоторых данных для подключения требуется подключения библиотеки:
```C++
#include <vector>
```
Если необходимо задать вектор фиксированного размера, то можно модифицировать его объявление:
```C++
int n = 2;
vector<string> v(n);
```

Присвоить значение вектору можно через "присвоение" и "фигурные скобки":
```C++
vector<string> v1 = {"ab", "cd", "de"};
vector<int> v2 = {1, 2, 3};
```

Изменение элементов под конкретными номерами происходит через квадратные скобки с нумерацией от 0:
```C++
v1[2] = "text"; // v1 = "ab", "cd", "text"
v2[0] = 5; // v2 = 5, 2, 3
```

При объявлении вектора с заданным размером, можно задать его заполнение. Дело в том, что по умолчанию каждый элемент вектора заполняется "пустым элементом". Но можно заполнить тем, чем хочется:
```C++
vector<bool> v1(30, false) // вектор из 30 bool значений, с заполнением "false"
vector<int> v2(10, 0) // вектор из 10 int значений, каждое из которых ноль
```

Ранее использовался специальный ключ при вызове цикла for для того, чтобы не заострять внимание на типе хранящихся в векторе переменных : `auto`. Но можно задать перебор элементов вектора через ссылки в более явной форме:
```C++
int n = 2;
vector<string> v(n);
for (string& s : v){
	cin >> s;
}
```
Иными словами конструкция внутри круглых скобок: элемент `s` является ссылкой на строку из вектора `v`
Полезные методы, которые можно производить над объектами класса `vector`:
- `v.push_back(s);` - к вектору `v` в конец добавляет элемент `s`
- `v.size()` - даёт размер вектора `v`
- `v.resize(n+10)` - расширяет вектор v, с исходным размером `n` до `n+10` дополняя пустыми значениями (оставляет нетронутым исходную часть вектора )
- `v.assign(n+10, 0)` - переобъявление вектора `v` и длиной `n` в вектор `v` размером `n+10` и заполнением `0` всех элементов 
- `v.clear()` - полная отчистка вектора
- `v1.insert(end(v1), begin(v2), end(v2));` - контакетинирует к концу вектора `v1` вектор `v2`
## #map

Словарь производит однонаправленное отображение из одной информации в другую. 
Для работы словаря требуется подключения библиотеки:
```C++
#include <map>
```

В примере ниже создаётся словарь отображения `int` (ключ) в `string` (значение): 
```C++
map<int, string> events; // 
events[1950] = "birthday of Bjarne Stroustrup"
```
Для получения доступа или объявления нового элемента используются квадратные скобки

Пример функции для отображения словаря:
```C++
void PrintMap (const map<int, string>& m){
	for (auto item : m){
		cout << item.first << ": " << item.second << endl;
	}
}
```
Здесь важно понять, что у контейнера "Словарь" есть 2 поля `item.first` - ключ из словаря и `item.second` - значение из словаря
Ключи в map хранятся отсортированными.

Пример функции разворота массива:
```C++
map<string, int> BuildReversedMap(const map<int, string>& m) {
	map<string, int> result;
	for (auto item : m) {
	  result[item.second] = item.first;
	}
	return result;
}
```

Можно определять словарь с помощью фигурных скобок. В фигурных скобках указывается сначала ключ, потом значение и дальше в следующих фигурных скобках объявляется следующая пара ключ-значение:
```C++
map<string, int> m = {{"one", 1}, {"two", 2}};  
```

Список полезных методов, которыми можно совершать над map:
- `m.size()` - узнать размер словаря, то есть количество пар ключ-значение в этом словаре
- `m.erase(key)` - удаление ключа и значения по этому ключу

## #set

Это контейнер уникальных элементов. Что интересно, но ключом к множеству будет работать по аналогии с #map: любой завяленный тип данных. Множество #set гарантирует наличие только уникальных элементов. Кроме того, множество не сохраняется порядок, а сортирует его. 
Для работы требуется подключение библиотеки:
```
#include <set>
```

пример кода с объявлением и встраиванием новых элементов множества:
```C++
//
set <string> names;
names.insert("Name 1");
names.insert("Name 2");
names.insert("Name 1"); 
// так как этот элемент уже существует в множестве names, он не будет добавлен
```

Работа с множеством и обращение к элементам множества схожи с map.
Объявлять новые элементы множества можно через фигурные скобки:
```C++
set<string> Names = {"Name 1", "Name 2", "Name 3"};
```
Множества можно сравнивать между собой, без вызова дополнительных методов а просто через знак `==`:
```C++
(set_1 == set_2)
```
#set и #vector хорошо работают друг с другом. Например, пусть есть вектор и мы хотим на его основе организовать множество, тогда такой код будет выглядеть следующим образом:
```C++
vector<string> v = {"a", "b", "a"};
set<string> s(begin(v), end(v));
```
Все контейнеры могут через итераторы легко взаимодействовать друг с другом (как в примере выше)

Список полезных методов, которыми можно совершать над map:
- `set.insert(var)` - встроить в переменную `set` переменную `var`. Элементы не дублируются. Типа хранимых переменных (`var`) определяется типом `set`
- `set.size()` - возвращает размер множества
- `set.erase(var)` - удаление из множества `set` элемента `var`
- `set.count(var)` - подсчёт количества элементов `var` в множестве `set`. Но так как множество имеет только уникальные элементы, значит этот метод скорее используется для проверки "наличия" переменной `var` в множестве `set`.

#  Домашние задания ( #HW )
1. [[Факториал]]
2. [[Палиндром]]
3. [[C++ Yandex White band/Week 2/3 Polindrom part 2/Отбор палиндромов|Отбор палиндромов]]
4. [[Максимизатор]]
5. [[C++ Yandex White band/Week 2/5 String move/Перемещение строк |Перемещение строк]]
6. [[Разворот последовательности]]
7. [[C++ Yandex White band/Week 2/7 Reverse_2/Разворот последовательности 2|Разворот последовательности 2]]
8. [[C++ Yandex White band/Week 2/8 Average Temperature/Средняя температура|Средняя температура]]
9. [[C++ Yandex White band/Week 2/9 Queue/Очередь|Очередь]]
10. [[C++ Yandex White band/Week 2/10 Daily Tasks/Ежемесячные дела|Ежемесячные дела]]
11. [[C++ Yandex White band/Week 2/11 Anagramma/Анаграммы|Анаграммы]]
12. [[C++ Yandex White band/Week 2/12 Capitals/Справочник столиц|Справочник столиц]]
13. [[C++ Yandex White band/Week 2/13 Bus_stops/Автобусные остановки|Автобусные остановки]]
14. [[C++ Yandex White band/Week 2/14 Bus_stops_2/Автобусные остановки 2|Автобусные остановки 2]]
15. [[C++ Yandex White band/Week 2/15 Uniq_strings/Количество уникальных строк|Количество уникальных строк]]
16. [[C++ Yandex White band/Week 2/16 BuildMapValuesSet/Множество значений словаря|Множество значений словаря]]
17. [[C++ Yandex White band/Week 2/17 Synonyms/Синонимы|Синонимы]]
18. [[C++ Yandex White band/Week 2/18 Bus_stops 3/Автобусные остановки 3|Автобусные остановки 3]]
