# Структуры исключения и перегрузка операторов

Сейчас может быть довольно странная часть текста, но всё же...

На текущий момент, мы научились делать структуры и классы. Но есть некоторая механика, которая немного усложняет код, но повышает его читаемость для будущего себя и других коллег, которые будут смотреть твой код без тебя. Возьмём пример: структура `date`:
```c++
struct Date {
	int day;
	int month;
	int year;
}
void PrintDate(const Date& date){
	cout << date.day << "." << date.month << "." << date.year << "\n";
}
int main(){
	Date date = {1, 1, 2017};
	return 0;
}
```
вывод:
```
1.1.2017
```

На первый взгляд всё работает и выводится. Но теперь представим, что структура не видна, и ты забыл, как она выглядит и имеется доступ только к куску кода из `main()`:
```C++
int main(){
	Date date = {10, 12, 11};
	return 0;
}
```
Какой здесь формат даты? Обычный: день-месяц-год? А может быть американский стиль: месяц-день-год? А может и вовсе: год-месяц-день? Для таких дел, можно с помощью структур и конструкторов решить этот вопрос. Пусть конструктор принимает на вход не просто целые числа, а некоторые "обёртки" над числами:
```c++
// структуры с одиним полем:
struct Day{
	int value;
};
struct Month{
	int value;
};
struct Year{
	int value;
};
struct Date {
	int day;
	int month;
	int year;
	// конструктор получает структуры
	Date(Day new_day, Month new_month, Year new_year){
		// и иницииализзирует поля Date по этим структурам
		day = new_day.value;
		month = new_month.value;
		year = new_year.value;
	}
}
```
В такой записи, мы не сможем воспользоваться вызовом:
```C++
int main(){
	Date date = {10, 12, 11};
	return 0;
}
```
Будет выдана ошибка компиляции, так как не получится компилятору однозначно распределить данные в структуры структур. И есть возможность теперь объявить поля структуры `Date` следующим образом:
```C++
// var 1
Date date(Day{10}, Month{11}, Year{12}); // Создай объект типа Day со значением 10 и так далее
// or
// var 2
Date date({10}, {11}, {12}); // разрешённая компилятором "оптимизация"
```
Так вот, мы почти решили проблему читаемости кода, но у нас остаётся `var 2` и получается, что это "как бы " решило вопрос, но с другой стороны вы наделали дополнительных делов, а толку почти ноль. Так не пойдёт. Для явной задачи дней-месяцев-годов нужно объявить конструкторы в структурах дней-месяцев-годов и с запретом на неявные преобразование типа: "целого числа к структурам типа день-месяц-год". Делается это путём "Явного конструктора" преобразования целых чисел к структурам через команду #explicit:
```C++
struct Day{
	int value;
	Explicit Day(int new_value){
		value = new_value;
	}
};
struct Month{
	int value;
	Explicit Month(int new_value){
		value = new_value;
	}
};
struct Year{
	int value;
	Explicit Year(int new_value){
		value = new_value;
	}
};
```
После этого для компилятора не останётся другого выбора кроме как требовать от разработчика явной задачи типов структур и останется только один единственный способ объявления структуры типа `Date`:
```C++
// var 1
Date date(Day{10}, Month{11}, Year{12});
// var 2
Date date(Day{10}, Month{11}, Year{12});

```



# Домашние задания ( #HW )
1. [[C++ Yandex White band/Week 4/1 LectureTitle/Структура LectureTitle|Структура LectureTitle]]
2. 